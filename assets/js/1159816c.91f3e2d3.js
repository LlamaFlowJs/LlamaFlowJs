"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9647],{824:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=t(65723),i=t(43327);const s={},a="Ingestion Pipeline",r={id:"modules/ingestion_pipeline/index",title:"Ingestion Pipeline",description:"An IngestionPipeline uses a concept of Transformations that are applied to input data.",source:"@site/docs/modules/ingestion_pipeline/index.md",sourceDirName:"modules/ingestion_pipeline",slug:"/modules/ingestion_pipeline/",permalink:"/modules/ingestion_pipeline/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Qdrant Vector Store",permalink:"/modules/vector_stores/qdrant"},next:{title:"Transformations",permalink:"/modules/ingestion_pipeline/transformations"}},c={},l=[{value:"Usage Pattern",id:"usage-pattern",level:2},{value:"Connecting to Vector Databases",id:"connecting-to-vector-databases",level:2},{value:"API Reference",id:"api-reference",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"ingestion-pipeline",children:"Ingestion Pipeline"}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.code,{children:"IngestionPipeline"})," uses a concept of ",(0,o.jsx)(n.code,{children:"Transformations"})," that are applied to input data.\nThese ",(0,o.jsx)(n.code,{children:"Transformations"})," are applied to your input data, and the resulting nodes are either returned or inserted into a vector database (if given)."]}),"\n",(0,o.jsx)(n.h2,{id:"usage-pattern",children:"Usage Pattern"}),"\n",(0,o.jsx)(n.p,{children:"The simplest usage is to instantiate an IngestionPipeline like so:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import fs from "node:fs/promises";\n\nimport {\n  Document,\n  IngestionPipeline,\n  MetadataMode,\n  OpenAIEmbedding,\n  TitleExtractor,\n  SimpleNodeParser,\n} from "llamaflowjs";\n\nasync function main() {\n  // Load essay from abramov.txt in Node\n  const path = "node_modules/llamaflowjs/examples/abramov.txt";\n\n  const essay = await fs.readFile(path, "utf-8");\n\n  // Create Document object with essay\n  const document = new Document({ text: essay, id_: path });\n  const pipeline = new IngestionPipeline({\n    transformations: [\n      new SimpleNodeParser({ chunkSize: 1024, chunkOverlap: 20 }),\n      new TitleExtractor(),\n      new OpenAIEmbedding(),\n    ],\n  });\n\n  // run the pipeline\n  const nodes = await pipeline.run({ documents: [document] });\n\n  // print out the result of the pipeline run\n  for (const node of nodes) {\n    console.log(node.getContent(MetadataMode.NONE));\n  }\n}\n\nmain().catch(console.error);\n'})}),"\n",(0,o.jsx)(n.h2,{id:"connecting-to-vector-databases",children:"Connecting to Vector Databases"}),"\n",(0,o.jsx)(n.p,{children:"When running an ingestion pipeline, you can also chose to automatically insert the resulting nodes into a remote vector store."}),"\n",(0,o.jsx)(n.p,{children:"Then, you can construct an index from that vector store later on."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import fs from "node:fs/promises";\n\nimport {\n  Document,\n  IngestionPipeline,\n  MetadataMode,\n  OpenAIEmbedding,\n  TitleExtractor,\n  SimpleNodeParser,\n  QdrantVectorStore,\n  VectorStoreIndex,\n} from "llamaflowjs";\n\nasync function main() {\n  // Load essay from abramov.txt in Node\n  const path = "node_modules/llamaflowjs/examples/abramov.txt";\n\n  const essay = await fs.readFile(path, "utf-8");\n\n  const vectorStore = new QdrantVectorStore({\n    host: "http://localhost:6333",\n  });\n\n  // Create Document object with essay\n  const document = new Document({ text: essay, id_: path });\n  const pipeline = new IngestionPipeline({\n    transformations: [\n      new SimpleNodeParser({ chunkSize: 1024, chunkOverlap: 20 }),\n      new TitleExtractor(),\n      new OpenAIEmbedding(),\n    ],\n    vectorStore,\n  });\n\n  // run the pipeline\n  const nodes = await pipeline.run({ documents: [document] });\n\n  // create an index\n  const index = VectorStoreIndex.fromVectorStore(vectorStore);\n}\n\nmain().catch(console.error);\n'})}),"\n",(0,o.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"/api/classes/IngestionPipeline",children:"IngestionPipeline"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},43327:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(22155);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);